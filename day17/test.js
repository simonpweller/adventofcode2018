const solve1 = require('./solve1');
const { Drop, simulate, parseInput, parseVein, getCell, setCell } = require('./utils');

const lines = [
  'x=495, y=2..7',
  'y=7, x=495..501',
  'x=501, y=3..7',
  'x=498, y=2..4',
  'x=506, y=1..2',
  'x=498, y=10..13',
  'x=504, y=10..13',
  'y=13, x=498..504',
];

const map = [
  ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
  ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
  ['.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
  ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
  ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
  ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
  ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
  ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
  ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
  ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
  ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
  ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
  ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
  ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
];

describe('Drop', () => {
  it('flows down if there is space', () => {
    const mapCopy = [...map.map(row => [...row])];
    const drops = [];
    const drop = new Drop(mapCopy, { x: 6, y: 1 }, drops);

    drop.flow();

    expect(drops.length).toBe(2);
    expect(mapCopy).toEqual([
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '|', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '|', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
    ]);
  });

  it('spreads to both sides if there ground below', () => {
    const mapCopy = [...map.map(row => [...row])];
    const drops = [];
    const drop = new Drop(mapCopy, { x: 5, y: 6 }, drops);

    drop.flow();

    expect(drops.length).toBe(3);
    expect(mapCopy).toEqual([
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '|', '|', '|', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
    ]);
  });

  it('does not replace walls when spreading', () => {
    const mapCopy = [...map.map(row => [...row])];
    const drops = [];
    const drop = new Drop(mapCopy, { x: 6, y: 6 }, drops);

    drop.flow();

    expect(drops.length).toBe(2);
    expect(mapCopy).toEqual([
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '.', '|', '|', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
    ]);
  });

  it('steadies if there ground below and it is surrounded by walls filled with water', () => {
    const map = [
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '|', '|', '|', '|', '|', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
    ];

    const drops = [];
    const drop = new Drop(map, { x: 5, y: 6 }, drops);

    drop.flow();

    expect(drops.length).toBe(1);
    expect(map).toEqual([
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '|', '|', '|', '~', '|', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
    ]);
  });

  it('steadies if there is steady water below and it is surrounded by walls filled with water', () => {
    const map = [
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '|', '|', '|', '|', '|', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '~', '~', '~', '~', '~', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
    ];

    const drops = [];
    const drop = new Drop(map, { x: 5, y: 5 }, drops);

    drop.flow();

    expect(drops.length).toBe(1);
    expect(map).toEqual([
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '.', '.', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '|', '|', '|', '~', '|', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '~', '~', '~', '~', '~', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.', '#', '.', '.', '.',],
      ['.', '.', '.', '.', '#', '#', '#', '#', '#', '#', '#', '.', '.', '.',],
    ]);
  });
});

describe('solve1', () => {
  it('returns the number of tiles water can reach', () => {
    expect(solve1(lines)).toBe(57);
  });
});

describe('simulate', () => {
  it('updates the map with water', () => {
    const expectedMap = [
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '|', '.', '.', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '|', '|', '|', '|', '.', '.', '.', '#', '.',],
      ['.', '#', '.', '.', '#', '~', '~', '#', '|', '.', '.', '.', '.', '.',],
      ['.', '#', '.', '.', '#', '~', '~', '#', '|', '.', '.', '.', '.', '.',],
      ['.', '#', '~', '~', '~', '~', '~', '#', '|', '.', '.', '.', '.', '.',],
      ['.', '#', '~', '~', '~', '~', '~', '#', '|', '.', '.', '.', '.', '.',],
      ['.', '#', '#', '#', '#', '#', '#', '#', '|', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '.', '.', '.', '.', '.', '|', '.', '.', '.', '.', '.',],
      ['.', '.', '.', '|', '|', '|', '|', '|', '|', '|', '|', '|', '.', '.',],
      ['.', '.', '.', '|', '#', '~', '~', '~', '~', '~', '#', '|', '.', '.',],
      ['.', '.', '.', '|', '#', '~', '~', '~', '~', '~', '#', '|', '.', '.',],
      ['.', '.', '.', '|', '#', '~', '~', '~', '~', '~', '#', '|', '.', '.',],
      ['.', '.', '.', '|', '#', '#', '#', '#', '#', '#', '#', '|', '.', '.',],
    ];
    expect(simulate(lines)).toEqual(expectedMap);
  });
});

describe('block inside a basin', () => {
  const lines = [
    'x=495, y=2..8',
    'x=505, y=2..8',
    'y=8, x=496..504',
    'y=4, x=498..499',
    'y=5, x=498..499',
  ];

  it('is parsed correctly', () => {
    const expectedMap = [
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.'],
      ['.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'],
      ['.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.'],
      ['.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.'],
      ['.', '#', '.', '.', '#', '#', '.', '.', '.', '.', '.', '#', '.'],
      ['.', '#', '.', '.', '#', '#', '.', '.', '.', '.', '.', '#', '.'],
      ['.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.'],
      ['.', '#', '.', '.', '.', '.', '.', '.', '.', '.', '.', '#', '.'],
      ['.', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '.'],
    ];

    expect(parseInput(lines)).toEqual(expectedMap);
  });

  it('fills with water correctly', () => {
    const expectedMap = [
      ['.', '.', '.', '.', '.', '.', '+', '.', '.', '.', '.', '.', '.'],
      ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],
      ['|', '#', '~', '~', '~', '~', '~', '~', '~', '~', '~', '#', '|'],
      ['|', '#', '~', '~', '~', '~', '~', '~', '~', '~', '~', '#', '|'],
      ['|', '#', '~', '~', '#', '#', '~', '~', '~', '~', '~', '#', '|'],
      ['|', '#', '~', '~', '#', '#', '~', '~', '~', '~', '~', '#', '|'],
      ['|', '#', '~', '~', '~', '~', '~', '~', '~', '~', '~', '#', '|'],
      ['|', '#', '~', '~', '~', '~', '~', '~', '~', '~', '~', '#', '|'],
      ['|', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '|'],
    ];

    expect(simulate(lines)).toEqual(expectedMap);
  });
});



describe('parseInput', () => {
  it('returns a 2d version of the input', () => {
    expect(parseInput(lines)).toEqual(map);
  });

  describe('parseVein', () => {
    it('returns an array with the coordinates of the vein', () => {
      expect(parseVein('x=495, y=2..7')).toEqual([
        {
          x: 495,
          y: 2,
        },
        {
          x: 495,
          y: 3,
        },
        {
          x: 495,
          y: 4,
        },
        {
          x: 495,
          y: 5,
        },
        {
          x: 495,
          y: 6,
        },
        {
          x: 495,
          y: 7,
        },
      ]);
    });

    it('accounts for the order of x and y', () => {
      expect(parseVein('y=7, x=495..501')).toEqual([
        {
          x: 495,
          y: 7,
        },
        {
          x: 496,
          y: 7,
        },
        {
          x: 497,
          y: 7,
        },
        {
          x: 498,
          y: 7,
        },
        {
          x: 499,
          y: 7,
        },
        {
          x: 500,
          y: 7,
        },
        {
          x: 501,
          y: 7,
        },
      ]);
    });
  });
});

describe('getCell', () => {
  it('returns the corresponding cell to a map', () => {
    expect(getCell(map, { x: 6, y: 0 })).toBe('+');
  });
})

describe('setCell', () => {
  it('updates the corresponding cell of a map', () => {
    const mapCopy = [...map.map(row => [...row])];

    setCell(mapCopy, { x: 1, y: 2 }, '*');
    expect(mapCopy[2][1]).toBe('*');
  });
})
